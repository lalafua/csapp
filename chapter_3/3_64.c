/*
3.64

For this exercise, we will examine the code generated by gcc for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.

The following C code has a function word_sum having structures as argument and return values, and a function prod that calls word_sum:

typedef struct {
    int a;
    int *p;
} str1;

typedef struct {
    int sum;
    int diff;
} str2;

str2 word_sum(str1 s1) {
    str2 result;
    result.sum = s1.a + *s1.p;
    result.diff = s1.a - *s1.p;
    return result;
}

int prod(int x, int y)
{
    str1 s1;
    str2 s2;
    s1.a = x;
    s1.p = &y;
    s2 = word_sum(s1);
    return s2.sum * s2.diff;
}

gcc generates the following code for these two functions:

1 word_sum:
2 pushl %ebp
3 movl %esp, %ebp
4 pushl %ebx
5 movl 8(%ebp), %eax        result.sum
6 movl 12(%ebp), %ebx       s1.a
7 movl 16(%ebp), %edx       s1.p
8 movl (%edx), %edx         *s1.p
9 movl %ebx, %ecx           
10 subl %edx, %ecx          s1.a - *s1.p
11 movl %ecx, 4(%eax)       result.diff = s1.a - *s1.p
12 addl %ebx, %edx          s1.a + *s1.p
13 movl %edx, (%eax)        result.sum = s1.a + *s1.p
14 popl %ebx
15 popl %ebp
16 ret $4

1 prod:
2 pushl %ebp
3 movl %esp, %ebp           
4 subl $20, %esp            allocate 20 bytes in stack
5 leal 12(%ebp), %edx       &y
6 leal -8(%ebp), %ecx       &s2.sum
7 movl 8(%ebp), %eax        x
8 movl %eax, 4(%esp)        x to stack as s1.a -16(%ebp)
9 movl %edx, 8(%esp)        &y to stack as s1.p -12(%ebp)
10 movl %ecx, (%esp)        &s2.sum to stack as result 
11 call word_sum
12 subl $4, %esp            
13 movl -4(%ebp), %eax      s2.diff
14 imull -8(%ebp), %eax     s2.sum * s2.diff
15 leave
16 ret

The instruction ret $4 is like a normal return instruction, but it increments the stack pointer by 8 (4 for the return address plus 4 additional), rather than 4.

A. We can see in lines 5–7 of the code for word_sum that it appears as if threevalues are being retrieved from the stack, even though the function has only a single argument. Describe what these three values are.

result at 8(%ebp)
s1.a at 12(%ebp)
s1.p at 16(%ebp)

B. We can see in line 4 of the code for prod that 20 bytes are allocated in thestack frame. These get used as five fields of 4 bytes each. Describe how each of these ﬁelds gets used.

result at 0(%esp)
s1.a at 4(%esp)
s1.p at 8(%esp)
s2.sum at -8(%ebp)
s2.diff at -4(%ebp)

C. How would you describe the general strategy for passing structures as arguments to a function?

结构体的每个成员都被单独压入栈中
调用者负责将结构体的所有成员按顺序压入栈
被调用函数通过栈偏移量访问各个成员
对于返回结构体，调用者还需要传递一个指向返回值存储位置的指针


D. How would you describe the general strategy for handling a structure as a return value from a function?

调用者在栈上分配空间来存储返回的结构体
调用者将指向这个空间的指针作为隐式的第一个参数传递给被调用函数
被调用函数通过这个指针直接在调用者的栈空间中构造返回值
函数返回时，调用者可以直接使用栈上的结构体数据
使用 ret $4 指令来调整栈指针，清理额外的参数

*/

typedef struct {
    int a;
    int *p;
} str1;

typedef struct {
    int sum;
    int diff;
} str2;

str2 word_sum(str1 s1) {
    str2 result;
    result.sum = s1.a + *s1.p;
    result.diff = s1.a - *s1.p;
    return result;
}

int prod(int x, int y)
{
    str1 s1;
    str2 s2;
    s1.a = x;
    s1.p = &y;
    s2 = word_sum(s1);
    return s2.sum * s2.diff;
}

int main(int argc, char** argv){
    int x = 10, y = 20;
    prod(x, y);
    return 0;
}
