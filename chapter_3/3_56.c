/*
 * 3.56
 * Consider the following assembly code:
 * x at %ebp+8,n at %ebp+12
 * 1 movl 8(%ebp), %esi     %esi = x
 * 2 movl 12(%ebp), %ebx    %ebx = n
 * 3 movl $-1, %edi         %edi = result = -1
 * 4 movl $1, %edx          %edx = mask = 1
 * 5 .L2:
 * 6 movl %edx, %eax        %eax = mask
 * 7 andl %esi, %eax        %eax = x & mask
 * 8 xorl %eax, %edi        %edi = result = result ^ (x&mask)
 * 9 movl %ebx, %ecx        %ecx = n
 * 10 sall %cl, %edx        %edx = mask = mask << n    (%cl is the low 2 bytes of %ecx)
 * 11 testl %edx, %edx      if mask != 0
 * 12 jne .L2               go to loop
 * 13 movl %edi, %eax       ret
 * The preceding code was generated by compiling C code that had the following overall form:
 * 1 int loop(int x, int n)
 * 2 {
 * 3    int result = ____;
 * 4    int mask;
 * 5    for (mask = ____; mask ____; mask = ____){
 * 6        result ^= ____;
 * 7    }
 * 8    return result;
 * 9 }
 * Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %eax. You will ﬁnd it helpful to examine the assembly code before,during, and after the loop to form a consistent mapping between the registers andthe program variables.
 * A. Which registers hold program values x, n, result, and mask?
 * B. What are the initial values of result and mask?
 * C. What is the test condition for mask?
 * D. How does mask get updated?
 * E. How does result get updated?
 * F. Fill in all the missing parts of the C code.
 */

int loop(int x, int n){
    int result = -1;
    int mask;
    for (mask = 1; mask != 0; mask = mask << n){
        result ^= x;
    }
    return result;
}

int main(int argc, char* argv[]){
    return 0;
}